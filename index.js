var service = require('./service.js');
var helper = require('./bot-helper.js');

function onInstallation(bot, installer) {
    if (installer) {
        bot.startPrivateConversation({
            user: installer
        }, function (err, convo) {
            if (err) {
                console.log(err);
            } else {
                convo.say('I am a bot that has just joined your team');
                convo.say('You must now /invite me to a channel so that I can be of use!');
            }
        });
    }
}

var config = {};
require('dotenv').config();

if (process.env.MONGODB_URI) {
    var BotkitStorage = require('botkit-storage-mongo');
    config = {
        storage: BotkitStorage({
            mongoUri: process.env.MONGODB_URI
        }),
    };
} else {
    config = {
        json_file_store: ((process.env.TOKEN) ? './db_slack_bot_ci/' : './db_slack_bot_a/'),
    };
}

if (process.env.TOKEN || process.env.SLACK_TOKEN) {
    //Treat this as a custom integration
    var customIntegration = require('./lib/custom_integrations');
    var token = (process.env.TOKEN) ? process.env.TOKEN : process.env.SLACK_TOKEN;
    var controller = customIntegration.configure(token, config, onInstallation);
} else if (process.env.CLIENT_ID && process.env.CLIENT_SECRET && process.env.PORT) {
    //Treat this as an app
    var app = require('./lib/apps');
    var controller = app.configure(process.env.PORT, process.env.CLIENT_ID, process.env.CLIENT_SECRET, config, onInstallation);
} else {
    console.log('Error: If this is a custom integration, please specify TOKEN in the environment. If this is an app, please specify CLIENTID, CLIENTSECRET, and PORT in the environment');
    process.exit(1);
}

controller.on('rtm_open', function (bot) {
    console.log('** The RTM api just connected!');
});

controller.on('rtm_close', function (bot) {
    console.log('** The RTM api just closed');
});

controller.on('message, message.channels, message.im', function (bot, message) {
    console.log(message);
});

controller.hears('start', 'direct_message', async function (bot, message) {
    
    await helper.setUser(message.user);

    if (await helper.getLevel(message.user) === 0) {
        bot.reply(message, 'Welcome! This bot will help you build your one page resume website. Please say \'I am ready\' when you have your linkedin and dblp public url along with your github username. If you do not have any of this, bot can generate an empty website for you!');
        await helper.incrementLevel(message.user);
    } else {
        bot.createConversation(message, function (err, convo) {
            convo.addMessage({
                text: 'Please say \'start\' to start a new session.',
            }, 'yes_thread');

            convo.addMessage({
                text: 'Alright',
            }, 'no_thread');

            convo.addMessage({
                text: 'Please Say \'I am ready\' when you are ready',
            }, 'level-1');

            convo.addMessage({
                text: 'Please Say Verify when you are done with your YML file Validation generated by the bot',
            }, 'level-2');

            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'default',
            }, 'bad_response');

            convo.addMessage({
                text: 'Session terminated you can say \'start\' to create a new session',
            }, 'session_terminated');

            convo.addQuestion('A session is already going on. Do you want to start a new session [y/n]?', async function (response, convo) {
                if (response.text === 'y') {
                    await helper.setLevel(0, convo.context.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('yes_thread');
                } else if (response.text === 'n') {
                    var level = await helper.getLevel(message.user);
                    if (level == 1) convo.gotoThread('level-1')
                    if (level == 2) convo.gotoThread('level-2')
                } else if (response.text === 'terminate') {
                    await helper.deleteUser(convo.context.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_response');
                }
            }, {}, 'default');
            convo.activate();
        });
    }
});

controller.hears('I am ready', 'direct_message', async function (bot, message) {
    if (await helper.getLevel(message.user) === 1) {
        bot.createConversation(message, function (err, convo) {
            // create a path for when a user says NO
            convo.addMessage({
                text: "Based on the information provided, I was able to generate a file. The file is uploaded at {{& vars.generatedYmlUrl.url}}. Go to this link and check the yml file. Please edit your email and phone number. Please also fill in if there are any other missing fields. You must comply with the yaml syntax editing and you cannot change the yaml schema that is already provided. Type in 'verify' to upload any revisions",
            }, 'Valid');

            // create a path where neither option was matched
            // this message has an action field, which directs botkit to go back to the `default` thread after sending this message.
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'default',
            }, 'bad_response');

            convo.addMessage({
                text: 'Session terminated you can say start to create a new session',
            }, 'session_terminated');
            convo.addQuestion('Please tell me if you have a LinkedIn account?[yes/no]', async function (response, convo) {
                if (response.text === 'yes') {
                    convo.gotoThread('Ask_Url_LinkedIn');
                } else if (response.text === 'no') {
                    convo.gotoThread('Ask_DBLP');
                } else if (response.text === 'terminate') {
                    await helper.setLevel(0, message.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_response');
                }
            }, {}, 'default');

            convo.addQuestion('Please provide your LinkedIn Profile Url in the form https://linkedin.com/in/<username>', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        console.log(response.text);
                        await helper.setLinkedInUrl(convo.context.user, response.text.substring(1, response.text.length - 1));
                        try {
                            if (await service.ExtractingLinkedInInfo(convo.context.user, response.text.substring(1, response.text.length - 1))) {
                                convo.gotoThread('Ask_DBLP');
                            } else {
                                bot.reply(message, 'Sorry! The Url is wrong...')
                                convo.gotoThread('default');
                            }
                        }
                        catch(ex){
                            bot.reply(message, 'Sorry! We have hit rate limiting. Please try again later')
                            convo.gotoThread('default');
                        }
                        
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_response');
                    },
                }
            ], {}, 'Ask_Url_LinkedIn');

            convo.addQuestion('Awesome! Now tell me if you have a DBLP account?[yes/no]', async function (response, convo) {
                if (response.text === 'yes') {
                    convo.gotoThread('yes_dblp_thread');
                } else if (response.text === 'no') {
                    convo.gotoThread('Ask_GitHub');
                } else if (response.text === 'terminate') {
                    await helper.setLevel(0, message.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_response');
                }
            }, {}, 'Ask_DBLP');
            //Question No. 4 
            convo.addQuestion('Please provide me with the DBLP link in the form of [http|https]://[your dblp profile url]', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        await helper.setDBLPUrl(convo.context.user, response.text.substring(1, response.text.length - 1));

                        try{
                            if (await service.ExtractingDBLPInfo(convo.context.user, response.text.substring(1, response.text.length - 1))) {
                                convo.gotoThread('Ask_GitHub');
                            } else {
                                bot.reply(message, 'Sorry! The Url is wrong...')
                                convo.gotoThread('Ask_DBLP');
                            }
                        }
                        catch(ex){
                            bot.reply(message, 'Sorry! Something went wrong...')
                            convo.gotoThread('Ask_DBLP');
                        }
                    },
                },
                {
                    pattern: 'no',
                    callback: function (response, convo) {
                        convo.gotoThread('no_thread');
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_response');
                    },
                }
            ], {}, 'yes_dblp_thread');

            convo.addQuestion('Now tell me if you have a Github account?[yes/no]', async function (response, convo) {
                if (response.text === 'yes') {
                    convo.gotoThread('yes_github_thread');
                } else if (response.text === 'no') {
                    try {
                        var link = await service.mergeAllInfo(convo.context.user);
                        if (link != null) {
                            convo.setVar('generatedYmlUrl', {
                                user: convo.context.user,
                                url: link
                            })
                            await helper.incrementLevel(convo.context.user);
                            convo.gotoThread('Valid');
                        } else {
                            bot.reply(message, 'Sorry! Something went wrong. Let\'s start again')
                            convo.gotoThread('default');
                        }
                    }
                    catch(ex){
                        bot.reply(message, 'Sorry! Something went wrong. Let\'s start again')
                        convo.gotoThread('default');
                    }
                    
                } else if (response.text === 'terminate') {
                    await helper.setLevel(0, message.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_response');
                }
            }, {}, 'Ask_GitHub');
            //Question 6
            convo.addQuestion('Amazing! Please provide me with Github User Name.', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        await helper.setGithubUserName(convo.context.user, response.text);
                        try {
                            if (await service.ExtractingGithubInfo(convo.context.user, response.text)) {
                                var link = await service.mergeAllInfo(convo.context.user);
                                if (link != null) {
                                    convo.setVar('generatedYmlUrl', {
                                        user: convo.context.user,
                                        url: link
                                    })
                                    await helper.incrementLevel(convo.context.user);
                                    convo.gotoThread('Valid');
                                } else {
                                    bot.reply(message, 'Sorry! Something went wrong. Let\'s start again')
                                    convo.gotoThread('default');
                                }
                            } else {
                                bot.reply(message, 'Sorry! The github info is wrong')
                                convo.gotoThread('Ask_GitHub')
                            }
                        }
                        catch(ex){
                            bot.reply(message, 'Sorry! Something went wrong')
                            convo.gotoThread('Ask_GitHub')
                        }
                        
                    },
                },
                {
                    pattern: 'no',
                    callback: function (response, convo) {
                        convo.gotoThread('no_thread');
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_response');
                    },
                }
            ], {}, 'yes_github_thread');

            convo.activate();
        });
    }
});

controller.hears('verify', 'direct_message', async function (bot, message) {
    if (await helper.getLevel(message.user) === 2) {
        //bot.reply(message,'Please give me the link');
        bot.createConversation(message, function (err, convo) {
            convo.addQuestion('Please give me a shareable link of the yml file in the form of [http|https]://[any file sharing website url]', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        try {
                            var path = await service.downloadYmlFile(response.text.substring(1, response.text.length - 1));

                            if (path != null) {
                                convo.setVar('userUploadedYmlUrl', {
                                    user: convo.context.user,
                                    url: path
                                })
                                console.log(path);
                                await helper.setUserUploadedYmlUrl(path, convo.context.user)

                                if (service.verifyYMLContent(convo.vars.userUploadedYmlUrl.url)) {
                                    convo.gotoThread('Template_Choice');
                                } else {
                                    convo.gotoThread('invalid_YML_content');
                                }
                            } else {
                                convo.gotoThread('bad_at_default');
                            }

                        }catch(ex){
                            bot.reply(message, 'Sorry, Something went wrong')
                            convo.gotoThread('bad_at_default');
                        }

                        
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_at_default');
                    },
                }
            ], {}, 'default');

            convo.addMessage({
                text: 'Session terminated. You can say \'start\' to create a new session',
            }, 'session_terminated');

            convo.addQuestion('Data verified. Do you want your CV in industrial or academic format?[i/a]', async function (response, convo) {
                if (response.text === 'i') {
                    // convo.setVar('choice', response.text);
                    convo.setVar('choice', {
                        user: convo.context.user,
                        choice: response.text
                    })
                    convo.gotoThread('valid2');
                } else if (response.text === 'a') {
                    // convo.setVar('choice', response.text);
                    convo.setVar('choice', {
                        user: convo.context.user,
                        choice: response.text
                    })
                    convo.gotoThread('valid2');
                    //convo.gotoThread('session_terminated');
                } else if (response.text === 'terminate') {
                    await helper.setLevel(0, message.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('Template_Choice');
                }
            }, {}, 'Template_Choice');

            convo.addQuestion('Do you want your CV in Github.io or in zipped format?[github/zip].', async function (response, convo) {
                if (response.text === 'github') {
                    convo.gotoThread('github_thread_username');
                } else if (response.text === 'zip') {

                    try {
                        if (convo.context.user == convo.vars.userUploadedYmlUrl.user &&
                            convo.context.user == convo.vars.choice.user) {
                            var link = await service.uploadZippedCV(convo.context.user, convo.vars.userUploadedYmlUrl.url, convo.vars.choice.choice);
                            if (link != null) {
                                await helper.setZippedCvUrl(link, convo.context.user)
                                convo.setVar('uploadedZippedCV', {
                                    user: convo.context.user,
                                    url: link
                                })
                                convo.gotoThread('zipped_CV_uploaded');
                            } else {
                                bot.reply(message, 'something went wrong...')
                                convo.gotoThread('valid2')
                            }
                        } else {
                            bot.reply(message, 'please only talk to bot one user at a time')
                            convo.gotoThread('valid2')
                        }
                    }catch(ex){
                        bot.reply(message, 'SOmething went wrong')
                        convo.gotoThread('valid2')
                    }

                    
                } else if (response.text === 'terminate') {
                    await helper.setLevel(0, message.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_at_valid2');
                }
            }, {}, 'valid2');

            convo.addQuestion('Make sure your Github does not have a repository named <username>.github.io. Now your Github username?', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        convo.setVar('githubUserName', {
                            user: convo.context.user,
                            username: response.text
                        })
                        convo.gotoThread('github_thread_token');
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_at_repoName');
                    },
                }
            ], {}, 'github_thread_username');

            convo.addQuestion('Make sure your token has appropriate permissions. Now input the token?', [{
                    pattern: /.*/,
                    callback: async function (response, convo) {
                        bot.reply(message, 'Pushing items to your github. This might take a while...')

                        convo.setVar('githubToken', {
                            user: convo.context.user,
                            token: response.text
                        })

                        try{
                            if (convo.context.user == convo.vars.githubUserName.user &&
                                convo.context.user == convo.vars.userUploadedYmlUrl.user &&
                                convo.context.user == convo.vars.choice.user) 
                            {
                                if (await service.createRepoForUser(convo.context.user, convo.vars.githubUserName.username, convo.vars.githubToken.token, convo.vars.userUploadedYmlUrl.url, convo.vars.choice.choice)) 
                                {
                                    convo.gotoThread('repoCreated');
                                } else {
                                    convo.gotoThread('bad_at_repoCreation');
                                }
                            } else {
                                bot.reply(message, 'please only talk to bot one user at a time')
                                convo.gotoThread('bad_at_repoCreation')
                            }
                        } catch(ex){
                            console.log(ex)
                            bot.reply(message, 'Something went wrong')
                            convo.gotoThread('bad_at_repoCreation')
                        }
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_at_token');
                    },
                }
            ], {}, 'github_thread_token');

            convo.addMessage({
                text: 'Thanks. The zipped CV has been uploaded successfully at {{& vars.uploadedZippedCV.url}}',
                action: 'terminate_session2',
            }, 'zipped_CV_uploaded');
            convo.addMessage({
                text: 'Sorry the repo could not be created. Make sure you provide valid token and repo name',
                action: 'github_thread_username',
            }, 'bad_at_repoCreation');
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'github_thread_token',
            }, 'bad_at_token');
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'github_thread_username',
            }, 'bad_at_repoName');
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'valid2',
            }, 'bad_at_valid2');
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'valid2',
            }, 'bad_at_valid2');
            convo.addMessage({
                text: 'website has been published at {{& vars.githubUserName.username}}.github.io ', //here will be the github.io link
                action: 'terminate_session2',
            }, 'repoCreated');
            // convo.addMessage({
            //     text: 'session terminated! You can say \'start\' to create a new session',
            //     action: "completed"
            // }, 'session_terminated');
            convo.addQuestion('Please say \'terminate\' to terminate the session', async function (response, convo) {
                if (response.text === 'terminate') {
                    await helper.setLevel(0, convo.context.user);
                    await service.deleteAllData(convo.context.user);
                    convo.gotoThread('session_terminated');
                } else {
                    convo.gotoThread('bad_at_terminate_session2');
                }
            }, {}, 'terminate_session2');
            convo.addMessage({
                text: 'Sorry I did not understand',
                action: 'terminate_session2',
            }, 'bad_at_terminate_session2');
            convo.addMessage({
                text: 'Sorry, maybe you did not upload a yml file',
                action: 'default',
            }, 'bad_at_default');
            convo.addMessage({
                text: 'Sorry, maybe the fields in the .yml file are not correctly filled up',
                action: 'default',
            }, 'invalid_YML_content');



            convo.on('end', function (convo) {
                console.log(convo.status);

                if (convo.status == 'completed') {
                    // do something useful with the users responses
                    console.log('edned well');

                } else {
                    console.log('ended bad');
                }

            });


            convo.activate();
        });

    } else { // bot replies an error message when the user is not in service.level 0
        bot.createConversation(message, function (err, convo) {
            // create a path for when a user says YES
            convo.addMessage({
                text: 'Please say \'start\' to start a new session.',
            }, 'yes_thread');

            // create a path for when a user says NO
            convo.addMessage({
                text: 'Alright',
            }, 'no_thread');

            // create a path where neither option was matched
            // this message has an action field, which directs botkit to go back to the `default` thread after sending this message.
            convo.addMessage({
                text: 'Sorry I did not understand.',
                action: 'default',
            }, 'bad_response');

            // Create a yes/no question in the default thread...
            convo.addQuestion('A session is already going on. Do you want to start a new session [y/n]?', [{
                    pattern: 'y',
                    callback: async function (response, convo) {
                        convo.gotoThread('yes_thread');
                        await helper.setLevel(0, convo.context.user);
                        await service.deleteAllData(message.user);
                    },

                },
                {
                    pattern: 'n',
                    callback: function (response, convo) {
                        convo.gotoThread('no_thread');
                    },
                },
                {
                    default: true,
                    callback: function (response, convo) {
                        convo.gotoThread('bad_response');
                    },
                }
            ], {}, 'default');

            convo.activate();
        });
    }
});

controller.on('direct_message,mention,direct_mention', async function (bot, message) {
    bot.api.reactions.add({
        timestamp: message.ts,
        channel: message.channel,
        name: 'robot_face',
    }, async function (err) {

        if (err) {
            console.log(err)
        }
        bot.reply(message, 'Sorry I did not understand. You can start a new session by saying \'start\'');
    });
});

controller.hears('terminate', 'direct_message', async function (bot, message) {
    bot.reply(message, 'Session terminated! You can start a new session by saying \'start\'');
    await helper.setLevel(0, message.user);
    await service.deleteAllData(message.user);
});


//https://resumeslackbot.herokuapp.com/oauth